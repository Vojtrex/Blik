
Blik.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000024  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  000000e8  2**0
                  ALLOC, LOAD, DATA
  2 .comment      0000005b  00000000  00000000  000000e8  2**0
                  CONTENTS, READONLY
  3 .stack.descriptors.hdr 0000002a  00000000  00000000  00000143  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000028  00000000  00000000  0000016d  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000052b  00000000  00000000  00000195  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000002f7  00000000  00000000  000006c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000183  00000000  00000000  000009b7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000048  00000000  00000000  00000b3c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000000f6  00000000  00000000  00000b84  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000049  00000000  00000000  00000c7a  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000018  00000000  00000000  00000cc3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .text         00000002  0000006a  0000006a  000000de  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000cdc  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .text.__vector_3 00000024  00000024  00000024  00000098  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .text.main    00000014  00000048  00000048  000000bc  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .text.__dummy_fini 00000002  0000006c  0000006c  000000e0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 17 .text.__dummy_funcs_on_exit 00000002  0000006e  0000006e  000000e2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 18 .text.__dummy_simulator_exit 00000002  00000070  00000070  000000e4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 19 .text.exit    0000000e  0000005c  0000005c  000000d0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 20 .text._Exit   00000002  00000072  00000072  000000e6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE

Disassembly of section .text:

00000000 <__vectors>:
   0:	09 c0       	rjmp	.+18     	; 0x14 <__ctors_end>
   2:	33 c0       	rjmp	.+102    	; 0x6a <__bad_interrupt>
   4:	32 c0       	rjmp	.+100    	; 0x6a <__bad_interrupt>
   6:	0e c0       	rjmp	.+28     	; 0x24 <_etext>
   8:	30 c0       	rjmp	.+96     	; 0x6a <__bad_interrupt>
   a:	2f c0       	rjmp	.+94     	; 0x6a <__bad_interrupt>
   c:	2e c0       	rjmp	.+92     	; 0x6a <__bad_interrupt>
   e:	2d c0       	rjmp	.+90     	; 0x6a <__bad_interrupt>
  10:	2c c0       	rjmp	.+88     	; 0x6a <__bad_interrupt>
  12:	2b c0       	rjmp	.+86     	; 0x6a <__bad_interrupt>

00000014 <__ctors_end>:
  14:	11 24       	eor	r1, r1
  16:	1f be       	out	0x3f, r1	; 63
  18:	cf e9       	ldi	r28, 0x9F	; 159
  1a:	cd bf       	out	0x3d, r28	; 61
  1c:	15 d0       	rcall	.+42     	; 0x48 <main>
  1e:	1e c0       	rjmp	.+60     	; 0x5c <exit>

00000020 <_exit>:
  20:	f8 94       	cli

00000022 <__stop_program>:
  22:	ff cf       	rjmp	.-2      	; 0x22 <__stop_program>

Disassembly of section .text:

0000006a <__bad_interrupt>:
  6a:	ca cf       	rjmp	.-108    	; 0x0 <__vectors>

Disassembly of section .text.__vector_3:

00000024 <__vector_3>:

#include <avr/interrupt.h>

#define LED PB0

ISR(TIM0_OVF_vect) {
  24:	1f 92       	push	r1
  26:	0f 92       	push	r0
  28:	0f b6       	in	r0, 0x3f	; 63
  2a:	0f 92       	push	r0
  2c:	11 24       	eor	r1, r1
  2e:	8f 93       	push	r24
  30:	9f 93       	push	r25
	// Toggle port B pin 4 output state
	PORTB ^= _BV(LED);
  32:	98 b3       	in	r25, 0x18	; 24
  34:	81 e0       	ldi	r24, 0x01	; 1
  36:	89 27       	eor	r24, r25
  38:	88 bb       	out	0x18, r24	; 24
}
  3a:	9f 91       	pop	r25
  3c:	8f 91       	pop	r24
  3e:	0f 90       	pop	r0
  40:	0f be       	out	0x3f, r0	; 63
  42:	0f 90       	pop	r0
  44:	1f 90       	pop	r1
  46:	18 95       	reti

Disassembly of section .text.main:

00000048 <main>:

int main(void) {
	// Set port B output 0 as output
	DDRB = _BV(LED);
  48:	81 e0       	ldi	r24, 0x01	; 1
  4a:	87 bb       	out	0x17, r24	; 23

	// Prescale timer to 1/1024th the clock rate
	TCCR0B |= _BV(CS02) | _BV(CS00);
  4c:	83 b7       	in	r24, 0x33	; 51
  4e:	85 60       	ori	r24, 0x05	; 5
  50:	83 bf       	out	0x33, r24	; 51

	// Enable timer overflow interrupt
	TIMSK0 |=_BV(TOIE0);
  52:	89 b7       	in	r24, 0x39	; 57
  54:	82 60       	ori	r24, 0x02	; 2
  56:	89 bf       	out	0x39, r24	; 57

	// Enable interrupts
	sei();
  58:	78 94       	sei
  5a:	ff cf       	rjmp	.-2      	; 0x5a <main+0x12>

Disassembly of section .text.__dummy_fini:

0000006c <_fini>:
  6c:	08 95       	ret

Disassembly of section .text.__dummy_funcs_on_exit:

0000006e <__funcs_on_exit>:
  6e:	08 95       	ret

Disassembly of section .text.__dummy_simulator_exit:

00000070 <__simulator_exit>:
  70:	08 95       	ret

Disassembly of section .text.exit:

0000005c <exit>:
  5c:	ec 01       	movw	r28, r24
  5e:	07 d0       	rcall	.+14     	; 0x6e <__funcs_on_exit>
  60:	05 d0       	rcall	.+10     	; 0x6c <_fini>
  62:	ce 01       	movw	r24, r28
  64:	05 d0       	rcall	.+10     	; 0x70 <__simulator_exit>
  66:	ce 01       	movw	r24, r28
  68:	04 d0       	rcall	.+8      	; 0x72 <_Exit>

Disassembly of section .text._Exit:

00000072 <_Exit>:
  72:	d6 df       	rcall	.-84     	; 0x20 <_exit>
